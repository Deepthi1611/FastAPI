# from fastapi import FastAPI, Request
# import random
# import string

# app = FastAPI()

# # The below is a middleware decorator that registers the function request_id_logging as middleware for HTTP requests.
# # Middleware in FastAPI is used to execute logic before and after an endpoint (route) is called. It is a way to add functionality to all requests and responses globally.
# # the below middleware is added to all apis and before going to the route, this middleware is called
# @app.middleware("http")
# async def request_id_logging(request: Request, call_next):
#     '''A special function call_next that will receive request as a parameter.
#     this function will pass the request to the corresponding path operation.
#     then it returns the response generated by the corresponding path operation'''

#     response = await call_next(request)
#     random_letters = ''.join(random.choice(string.ascii_letters) for _ in range(10))
#     print(f"Log {random_letters}")
#     response.headers['X-Request-ID'] = random_letters
#     return response

# @app.get("/")
# async def say_hi():
#     return 'hello world'

from fastapi import FastAPI, Request, Response
from starlette.middleware.base import BaseHTTPMiddleware
import time
from collections import defaultdict
from typing import Dict

app = FastAPI()


class AdvancedMiddleware(BaseHTTPMiddleware):
    def __init__(self, app):
        super().__init__(app)
        self.rate_limit_records : Dict[str, float] = defaultdict(float)

        async def log_message(self, message: str):
            print(message)
        
        async def dispatch(self, request: Request, call_next):
            client_ip = request.client.host
            current_time = time.time()
            if current_time - self.rate_limit_records[client_ip] < 1: # 1 request per second limit
                return Response(content='Rate limit exceeded', status_code=429)
            
            self.rate_limit_records[client_ip] = current_time
            path = request.url.path
            await self.log_message(f"Request to {path}")

            # process the request
            start_time = time.time()
            response = await call_next(request)
            process_time = time.time()-start_time

            # add custom headers without modifying the actual headers
            custom_headers = {'X-Process-Time': str(process_time)}
            for header, value in custom_headers.items():
                response.headers.append(header, value)

            # Asynchronous logging for processing time
            await self.log_message(f"message for {path} took {process_time} seconds")

            return response
        
# Add the advanced middleware to the app
app.add_middleware(AdvancedMiddleware)

@app.get("/")
async def say_hi():
    return 'hello world'